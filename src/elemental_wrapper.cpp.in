/*
Routines for doing run-time dispatching rather than compile-time
template resolution of Elemental operations. This instantiates
a large set of the available templates and makes them available
through run-time mechanisms.
*/

/*
Templating support code
*/

{{py:
ALL_DISTRIBUTIONS = [
    ('MC', 'MR'),
    ('MC', 'STAR')
]

DTYPES = {
   'ELEM_SINGLE_REAL' : 'float',
   'ELEM_SINGLE_COMPLEX' : 'Complex<float> ',
   'ELEM_DOUBLE_REAL' : 'double',
   'ELEM_DOUBLE_COMPLEX' : 'Complex<double> '
}

class Context:
    def __init__(self, dtype_enum, dtype_t, coldist, rowdist):
        self.dtype_enum = dtype_enum
        self.dtype_t = dtype_t
        self.coldist = coldist
        self.rowdist = rowdist
        if coldist is not None:
            assert rowdist is not None
            self.dist = '%s,%s' % (coldist, rowdist)
            self.matrix_t = 'DistMatrix<%s, %s, %s, int> ' % (dtype_t, coldist, rowdist)
        else:
            # coldist/rowdist is None, use AbstractDistMatrix
            self.matrix_t = 'AbstractDistMatrix<%s, int> ' % dtype_t

    def scalar(self, expr):
        if self.dtype_t.startswith('Complex'):
            return '(%s((%s).real, (%s).imag))' % (self.dtype_t, expr, expr)
        else:
            return '((%s)(%s).real)' % (self.dtype_t, expr)
    
    def matrix(self, wrapper_expr):
        return '(*((%s*)(%s)->cpp_obj))' % (self.matrix_t, wrapper_expr)
}}

{{def generic_dispatch(body, distributions, dtype_expr, coldist_expr, rowdist_expr, errcode)}}
{{py:
if isinstance(distributions, str):
    distributions = [tuple(x.split(',')) for x in distributions.split()]
}}
  try {
    if (0) {}

    {{for dtype_enum, dtype_t in DTYPES.items()}}
    else if (({{dtype_expr}}) == {{dtype_enum}}) {

      {{if distributions is None}}
      {{# use abstract superclass }}

      {{py: ctx = Context(dtype_enum, dtype_t, None, None)}}
      {{body(ctx)}}

      {{else}}
      {{# use a new if-test to statically dispatch on distribution }}

      if (0) {}
      {{for coldist, rowdist in distributions}}
      else if (({{coldist_expr}}) == ELEM_{{coldist}} &&
               ({{rowdist_expr}}) == ELEM_{{rowdist}}) {
        {{py: ctx = Context(dtype_enum, dtype_t, coldist, rowdist)}}
        {{body(ctx)}}
      }
      {{endfor}}
      else {
        throw std::logic_error("invalid colDist/rowDist combination");
      }

      {{endif}}

    }
    {{endfor}}
    else {
      throw std::logic_error("invalid dtype");
    }
    {{if errcode is not None and errcode != 'NULL'}}
    return 0;
    {{endif}}
  } catch (std::exception& e) {
    {{if errcode is not None}}
      set_error(e.what());
      return {{errcode}};
    {{endif}}
  } catch (...) {
    {{if errcode is not None}}
      set_error("non-std exception");
      return {{errcode}};
    {{endif}}
  }
{{enddef}}

{{def dispatch(body, distributions, matrix_exprs=['matrix'], errcode='ELEM_ERROR_LOGIC')}}
{{py:
if isinstance(matrix_exprs, str):
    matrix_exprs = matrix_exprs.split()
}}
  {{for matrix_expr in matrix_exprs[1:]}}
  if ((({{matrix_expr}})->dtype != ({{matrix_exprs[0]}})->dtype) ||
      (({{matrix_expr}})->col_dist != ({{matrix_exprs[0]}})->col_dist) ||
      (({{matrix_expr}})->row_dist != ({{matrix_exprs[0]}})->row_dist)) {
    {{if errcode is not None}}
      set_error("dtype/col_dist/row_dist does not match up");
      return {{errcode}};
    {{else}}
      return;
    {{endif}}    
  }
  {{endfor}}
  int _dtype = {{matrix_exprs[0]}}->dtype;
  {{if distributions is not None}}
  int _col_dist = {{matrix_exprs[0]}}->col_dist;
  int _row_dist = {{matrix_exprs[0]}}->row_dist;
  {{endif}}
  {{generic_dispatch(body, distributions, '_dtype', '_col_dist', '_row_dist', errcode)}}
{{enddef}}


/*
Wrapping support code, global environment
*/
#include <stdio.h>
#include <string.h>

#include "elemental_wrapper.h"
#include "elemental.hpp"

using namespace elem;

static Orientation as_orientation(int x) {
  switch (x) {
    case ELEM_NORMAL:
      return NORMAL;
    case ELEM_TRANSPOSE:
      return TRANSPOSE;
    case ELEM_ADJOINT:
      return ADJOINT;
    default:
      throw std::logic_error("invalid orientation code");
  }
}

static UpperOrLower as_uplo(int x) {
  switch (x) {
  case ELEM_LOWER:
    return LOWER;
  case ELEM_UPPER:
    return UPPER;
  default:
    throw std::logic_error("invalid upper/lower code");
  }
}

#define MAX_ERR_LEN 1024
static char _errmsg[MAX_ERR_LEN];

static void set_error(const char *msg) {
  strncpy(_errmsg, msg, MAX_ERR_LEN);
  _errmsg[MAX_ERR_LEN - 1] = '\0'; // in case of truncation
}




/* 
  Global
*/
char *elem_errmsg() {
  return _errmsg;
}

int elem_initialize(int* argc, char **argv) {
  try {
    Initialize(*argc, argv);
    return 0;
  } catch (std::exception &e) {
    set_error(e.what());
    return NULL;
  } catch (...) {
    set_error("non-std exception");
    return NULL;
  }
}

void elem_finalize() {
  try {
    Finalize();
  } catch (...) {
    return;
  }
}

/*
  DistMatrix and matrix operations
*/

elem_matrix *elem_create_matrix(int dtype, int col_dist, int row_dist,
                                int height, int width, int col_alignment,
                                int row_alignment, void *buffer,
                                int lda, elem_grid *grid_handle) {
  const Grid& grid = *(const Grid*)grid_handle;
  {{def body(ctx)}}
    {{if ctx.dist == 'MC,MR'}}
      {{ctx.matrix_t}} *matrix = new {{ctx.matrix_t}}(
            height, width, col_alignment, row_alignment,
            ({{ctx.dtype_t}}*)buffer, lda, grid);
    {{elif ctx.dist == 'MC,STAR'}}
      {{ctx.matrix_t}} *matrix = new {{ctx.matrix_t}}(
            height, width, col_alignment,
            ({{ctx.dtype_t}}*)buffer, lda, grid);
    {{else}}
      {{py: assert False}}
    {{endif}}
      elem_matrix *wrapper = new elem_matrix();
      wrapper->dtype = dtype;
      wrapper->col_dist = col_dist;
      wrapper->row_dist = row_dist;
      wrapper->cpp_obj = matrix;
      return wrapper;
  {{enddef}}

  {{generic_dispatch(body, ALL_DISTRIBUTIONS, 'dtype', 'col_dist', 'row_dist', 'NULL')}}
}

void elem_destroy_matrix(elem_matrix *matrix) {
  {{def body(ctx)}}
    delete ({{ctx.matrix_t}}*)matrix->cpp_obj;
    delete matrix;
  {{enddef}}
  {{dispatch(body, None, 'matrix', None)}}
}

int elem_gemm(int orientation_of_a,
              int orientation_of_b,
              elem_complex alpha,
              elem_matrix *A,
              elem_matrix *B,
              elem_complex beta,
              elem_matrix *C) {
  {{def body(ctx)}}
    Gemm(as_orientation(orientation_of_a),
         as_orientation(orientation_of_b),
         {{ctx.scalar('alpha')}},
         {{ctx.matrix('A')}},
         {{ctx.matrix('B')}},
         {{ctx.scalar('beta')}},
         {{ctx.matrix('C')}});
  {{enddef}}
  {{dispatch(body, 'MC,MR', 'A B C')}}
}

int elem_cholesky(int uplo, elem_matrix *A) {
  {{def body(ctx)}}
    Cholesky(as_uplo(uplo), {{ctx.matrix('A')}});
  {{enddef}}
  {{dispatch(body, 'MC,MR', 'A')}}
}

int elem_print(elem_matrix *matrix) {
  {{def body(ctx)}}
  {{ctx.matrix('matrix')}}.Print();
  {{enddef}}
  {{dispatch(body, None, 'matrix')}}
}

int elem_set_to_identity(elem_matrix *matrix) {
  {{def body(ctx)}}
  {{ctx.matrix('matrix')}}.SetToIdentity();
  {{enddef}}
  {{dispatch(body, None, 'matrix')}}
}


/*
  Grid
*/

elem_grid *elem_create_grid(MPI_Comm comm, int height, int width) {
  try {
    return (elem_grid*)(new Grid(comm, height, width));
  } catch (std::exception &e) {
    set_error(e.what());
    return NULL;
  } catch (...) {
    set_error("non-std exception");
    return NULL;
  }
}
 
void elem_destroy_grid(elem_grid *grid) {
  delete (Grid*)grid;
}

int elem_local_length(int n, int index, int alignment, int modulus) {
  return LocalLength(n, index, alignment, modulus);
}

{{for property in 'MCRank MRRank Height Width'.split()}}
int elem_grid_{{property.lower()}}(elem_grid *grid) {
  return ((Grid*)grid)->{{property}}();
}
{{endfor}}
